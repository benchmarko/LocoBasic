import type { ActionDict, Node } from "ohm-js";
import type { IVm, ISemantics, SnippetDataType, UsedLabelEntryType } from "./Interfaces";
import { SemanticsHelper } from "./SemanticsHelper";
type RecursiveArray<T> = T | RecursiveArray<T>[];
export declare const CommaOpChar = "\u2192";
export declare const TabOpChar = "\u21D2";
declare const codeSnippetsData: {
    _o: IVm;
    _d: SnippetDataType;
    cls(): void;
    frame(): Promise<void>;
    printText(_text: string): void;
    remain(timer: number): number;
    resetText(): void;
};
export declare class Semantics implements ISemantics {
    private readonly helper;
    constructor();
    resetParser(): void;
    getUsedLabels(): Record<string, Record<string, UsedLabelEntryType>>;
    getSemanticsActions(): {
        Program(lines: Node): string;
        LabelRange(start: Node, minus: Node, end: Node): string;
        LetterRange(start: Node, minus: Node, end: Node): string;
        Line(label: Node, stmts: Node, comment: Node, _eol: Node): string;
        Statements(stmt: Node, _stmtSep: Node, stmts: Node): any;
        ArrayAssign(ident: Node, _op: Node, e: Node): string;
        Assign(ident: Node, _op: Node, e: Node): string;
        LoopBlockContent(separator: Node, stmts: Node): string;
        LoopBlockSeparator_colon(_colonLit: Node): string;
        LoopBlockSeparator_newline(comment: Node, eol: Node, _label: Node): string;
        Abs(_absLit: Node, _open: Node, e: Node, _close: Node): string;
        After(_afterLit: Node, e1: Node, _comma1: Node, e2: Node, _gosubLit: Node, label: Node): string;
        Asc(_ascLit: Node, _open: Node, e: Node, _close: Node): string;
        Atn(_atnLit: Node, _open: Node, e: Node, _close: Node): string;
        Auto(lit: Node, label: Node, comma: Node, step: Node): string;
        BinS(_binLit: Node, _open: Node, e: Node, _comma: Node, n: Node, _close: Node): string;
        Border(lit: Node, num: Node, comma: Node, num2: Node): string;
        Call(lit: Node, args: Node): string;
        Cat: (lit: Node, ...args: Node[]) => string;
        Chain(lit: Node, merge: Node, file: Node, comma: Node, num: Node, comma2: Node, del: Node, num2: Node): string;
        ChrS(_chrLit: Node, _open: Node, e: Node, _close: Node): string;
        Cint(_cintLit: Node, _open: Node, e: Node, _close: Node): string;
        Clear: (lit: Node, ...args: Node[]) => string;
        Clear_input(lit: Node, inputLit: Node): string;
        Clg(lit: Node, num: Node): string;
        Closein: (lit: Node, ...args: Node[]) => string;
        Closeout: (lit: Node, ...args: Node[]) => string;
        Cls(_clsLit: Node, stream: Node): string;
        Comment(_commentLit: Node, remain: Node): string;
        Cont: (lit: Node, ...args: Node[]) => string;
        CopychrS(lit: Node, open: Node, stream: Node, close: Node): string;
        Cos: (lit: Node, _open: Node, e: Node, _close: Node) => string;
        Creal(_lit: Node, _open: Node, num: Node, _close: Node): string;
        Cursor(lit: Node, num: Node, comma: Node, num2: Node): string;
        Data(_datalit: Node, args: Node): string;
        DecS(_decLit: Node, _open: Node, num: Node, _comma: Node, format: Node, _close: Node): string;
        Def(_defLit: Node, _fnLit: Node, assign: Node): string;
        DefArgs(_open: Node, arrayIdents: Node, _close: Node): string;
        DefAssign(ident: Node, args: Node, _equal: Node, e: Node): string;
        Defint(lit: Node, letterRange: Node): string;
        Defreal(lit: Node, letterRange: Node): string;
        Defstr(lit: Node, letterRange: Node): string;
        Deg(_degLit: Node): string;
        Delete(lit: Node, labelRange: Node): string;
        Derr(lit: Node): string;
        Di: (lit: Node, ...args: Node[]) => string;
        Dim(_dimLit: Node, dimArgs: Node): string;
        Draw: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, e3: Node, _comma3: Node, e4: Node) => string;
        Drawr: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, e3: Node, _comma3: Node, e4: Node) => string;
        Edit(lit: Node, label: Node): string;
        Ei: (lit: Node, ...args: Node[]) => string;
        End(_endLit: Node): string;
        Ent(lit: Node, nums: Node): string;
        Env(lit: Node, nums: Node): string;
        Erase(_eraseLit: Node, arrayIdents: Node): string;
        Erl(lit: Node): string;
        Err(lit: Node): string;
        Error(_errorLit: Node, e: Node): string;
        Every(_everyLit: Node, e1: Node, _comma1: Node, e2: Node, _gosubLit: Node, label: Node): string;
        Exp(_expLit: Node, _open: Node, e: Node, _close: Node): string;
        Fill(lit: Node, num: Node): string;
        Fix(_fixLit: Node, _open: Node, e: Node, _close: Node): string;
        Fre(lit: Node, open: Node, e: Node, close: Node): string;
        AnyFnArgs(_open: Node, args: Node, _close: Node): string;
        FnIdent(fnIdent: Node, args: Node): string;
        StrFnIdent(fnIdent: Node, args: Node): string;
        For(_forLit: Node, variable: Node, _eqSign: Node, start: Node, _dirLit: Node, end: Node, _stepLit: Node, step: Node): string;
        ForNextBlock: (startNode: Node, content: Node, separator: Node, endNode: Node) => string;
        Frame(_frameLit: Node): string;
        Gosub(_gosubLit: Node, e: Node): string;
        Goto(lit: Node, label: Node): string;
        GraphicsPaper(lit: Node, paperLit: Node, num: Node): string;
        GraphicsPen(_graphicsLit: Node, _penLit: Node, e: Node): string;
        HexS(_hexLit: Node, _open: Node, e: Node, _comma: Node, n: Node, _close: Node): string;
        Himem(lit: Node): string;
        IfExp_label(label: Node): string;
        If(_iflit: Node, condExp: Node, _thenLit: Node, thenStat: Node, elseLit: Node, elseStat: Node): string;
        Ink(_inkLit: Node, num: Node, _comma: Node, col: Node, _comma2: Node, col2: Node): string;
        Inkey(lit: Node, open: Node, num: Node, close: Node): string;
        InkeyS(_inkeySLit: Node): string;
        Inp(lit: Node, open: Node, num: Node, close: Node): string;
        Input(_inputLit: Node, stream: Node, _comma: Node, message: Node, _semi: Node, ids: Node): string;
        Instr_noLen(_instrLit: Node, _open: Node, e1: Node, _comma: Node, e2: Node, _close: Node): string;
        Instr_len(_instrLit: Node, _open: Node, len: Node, _comma1: Node, e1: Node, _comma2: Node, e2: Node, _close: Node): string;
        Int(_intLit: Node, _open: Node, e: Node, _close: Node): string;
        Joy(lit: Node, open: Node, num: Node, close: Node): string;
        Key(lit: Node): string;
        LeftS(_leftLit: Node, _open: Node, e1: Node, _comma: Node, e2: Node, _close: Node): string;
        Len(_lenLit: Node, _open: Node, e: Node, _close: Node): string;
        Let(_letLit: Node, assign: Node): string;
        LineInput(lit: Node, inputLit: Node, stream: Node, comma: Node, message: Node, semi: Node, e: Node): string;
        List(lit: Node, labelRange: Node, comma: Node, stream: Node): string;
        Load(lit: Node, file: Node, comma: Node, address: Node): string;
        Locate(lit: Node, stream: Node, comma: Node, x: Node, comma2: Node, y: Node): string;
        Log(_logLit: Node, _open: Node, e: Node, _close: Node): string;
        Log10(_log10Lit: Node, _open: Node, e: Node, _close: Node): string;
        LowerS(_lowerLit: Node, _open: Node, e: Node, _close: Node): string;
        Mask(lit: Node, num: Node, comma: Node, num2: Node, comma2: Node, num3: Node): string;
        Max(_maxLit: Node, _open: Node, args: Node, _close: Node): string;
        Memory(lit: Node, num: Node): string;
        Merge(lit: Node, file: Node): string;
        MidS(_midLit: Node, _open: Node, e1: Node, _comma1: Node, e2: Node, _comma2: Node, e3: Node, _close: Node): string;
        MidSAssign(_midLit: Node, _open: Node, ident: Node, _comma1: Node, e2: Node, _comma2: Node, e3: Node, _close: Node, _op: Node, e: Node): string;
        Min(_minLit: Node, _open: Node, args: Node, _close: Node): string;
        Mode(_modeLit: Node, e: Node): string;
        Move: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, e3: Node, _comma3: Node, e4: Node) => string;
        Mover: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, e3: Node, _comma3: Node, e4: Node) => string;
        New: (lit: Node, ...args: Node[]) => string;
        Next(_nextLit: Node, _variable: Node): string;
        On_numGosub(_onLit: Node, e1: Node, _gosubLit: Node, args: Node): string;
        On_numGoto(lit: Node, num: Node, gotoLit: Node, labels: Node): string;
        On_breakCont(lit: Node, breakLit: Node, contLit: Node): string;
        On_breakGosub(lit: Node, breakLit: Node, gosubLit: Node, label: Node): string;
        On_breakStop(lit: Node, breakLit: Node, stopLit: Node): string;
        On_errorGoto(lit: Node, errorLit: Node, gotoLit: Node, label: Node): string;
        Openin(lit: Node, file: Node): string;
        Openout(lit: Node, file: Node): string;
        Origin(_originLit: Node, x: Node, _comma1: Node, y: Node): string;
        Out(lit: Node, num: Node, comma: Node, num2: Node): string;
        Paper(_paperLit: Node, stream: Node, _comma: Node, e: Node): string;
        Peek(lit: Node, open: Node, num: Node, close: Node): string;
        Pen(_penLit: Node, stream: Node, _comma: Node, e: Node, _comma2: Node, e2: Node): string;
        Pi(_piLit: Node): string;
        Plot: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, e3: Node, _comma3: Node, e4: Node) => string;
        Plotr: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, e3: Node, _comma3: Node, e4: Node) => string;
        Poke(lit: Node, num: Node, comma: Node, num2: Node): string;
        Pos(lit: Node, open: Node, streamLit: Node, num: Node, close: Node): string;
        PrintArg_strCmp(_cmp: Node, args: Node): any;
        PrintArg_usingNum(_printLit: Node, format: Node, _semi: Node, numArgs: Node): string;
        PrintArg_commaOp(_comma: Node): string;
        StreamArg(streamLit: Node, stream: Node): string;
        Print(_printLit: Node, stream: Node, _comma: Node, args: Node, semi: Node): string;
        Rad(_radLit: Node): string;
        Randomize(lit: Node, num: Node): string;
        Read(_readlit: Node, args: Node): string;
        Release(lit: Node, num: Node): string;
        Rem(_remLit: Node, remain: Node): string;
        Remain(_remainLit: Node, _open: Node, e: Node, _close: Node): string;
        Renum(lit: Node, num: Node, comma: Node, num2: Node, comma2: Node, num3: Node): string;
        Restore(_restoreLit: Node, e: Node): string;
        Resume(lit: Node, labelOrNext: Node): string;
        Return(_returnLit: Node): string;
        RightS(_rightLit: Node, _open: Node, e1: Node, _comma: Node, e2: Node, _close: Node): string;
        Rnd(_rndLit: Node, _open: Node, _e: Node, _close: Node): string;
        Round(_roundLit: Node, _open: Node, value: Node, _comma: Node, decimals: Node, _close: Node): string;
        Rsx(_rsxLit: Node, cmd: Node, e: Node): string;
        RsxAddressOfIdent(_adressOfLit: Node, ident: Node): string;
        RsxArgs(_comma: Node, args: Node): string;
        Run(lit: Node, labelOrFileOrNoting: Node): string;
        Save(lit: Node, file: Node, comma: Node, type: Node, comma2: Node, num: Node, comma3: Node, num2: Node, comma4: Node, num3: Node): string;
        Sgn(_sgnLit: Node, _open: Node, e: Node, _close: Node): string;
        Sin: (lit: Node, _open: Node, e: Node, _close: Node) => string;
        Sound(lit: Node, args: Node): string;
        SpaceS(_stringLit: Node, _open: Node, len: Node, _close: Node): string;
        Spc(_lit: Node, _open: Node, len: Node, _close: Node): string;
        Speed_ink(lit: Node, inkLit: Node, num: Node, comma: Node, num2: Node): string;
        Speed_key(lit: Node, keyLit: Node, num: Node, comma: Node, num2: Node): string;
        Speed_write(lit: Node, writeLit: Node, num: Node): string;
        Sq(lit: Node, open: Node, num: Node, close: Node): string;
        Sqr(_sqrLit: Node, _open: Node, e: Node, _close: Node): string;
        Stop(_stopLit: Node): string;
        StrS(_strLit: Node, _open: Node, e: Node, _close: Node): string;
        StringS_str(_stringLit: Node, _open: Node, len: Node, _commaLit: Node, chr: Node, _close: Node): string;
        StringS_num(_stringLit: Node, _open: Node, len: Node, _commaLit: Node, num: Node, _close: Node): string;
        Symbol_def(lit: Node, args: Node): string;
        Symbol_after(lit: Node, afterLit: Node, num: Node): string;
        Tab(_lit: Node, _open: Node, num: Node, _close: Node): string;
        Tag(_tagLit: Node, stream: Node): string;
        Tagoff(_tagoffLit: Node, stream: Node): string;
        Tan: (lit: Node, _open: Node, e: Node, _close: Node) => string;
        Test(lit: Node, open: Node, num: Node, comma: Node, num2: Node, close: Node): string;
        Testr(lit: Node, open: Node, num: Node, comma: Node, num2: Node, close: Node): string;
        Time(_timeLit: Node): string;
        Troff: (lit: Node, ...args: Node[]) => string;
        Tron: (lit: Node, ...args: Node[]) => string;
        Unt(_lit: Node, _open: Node, num: Node, _close: Node): string;
        UpperS(_upperLit: Node, _open: Node, e: Node, _close: Node): string;
        Val(_upperLit: Node, _open: Node, e: Node, _close: Node): string;
        Vpos(lit: Node, open: Node, streamLit: Node, num: Node, close: Node): string;
        Wait(lit: Node, num: Node, comma: Node, num2: Node, comma2: Node, num3: Node): string;
        Wend(_wendLit: Node): string;
        While(_whileLit: Node, e: Node): string;
        WhileWendBlock: (startNode: Node, content: Node, separator: Node, endNode: Node) => string;
        Width(lit: Node, num: Node): string;
        Window_def(lit: Node, stream: Node, comma0: Node, num: Node, comma: Node, num2: Node, comma2: Node, num3: Node, comma3: Node, num4: Node): string;
        Window_swap(lit: Node, swapLit: Node, num: Node, comma: Node, num2: Node): string;
        Write(_printLit: Node, stream: Node, _comma: Node, args: Node): string;
        Xpos(_xposLit: Node): string;
        Ypos(_xposLit: Node): string;
        Zone(_lit: Node, num: Node): string;
        AndExp_and(a: Node, _op: Node, b: Node): string;
        NotExp_not(_op: Node, e: Node): string;
        OrExp_or(a: Node, _op: Node, b: Node): string;
        XorExp_xor(a: Node, _op: Node, b: Node): string;
        AddExp_minus(a: Node, _op: Node, b: Node): string;
        AddExp_plus(a: Node, _op: Node, b: Node): string;
        CmpExp_eq(a: Node, _op: Node, b: Node): string;
        CmpExp_ge(a: Node, _op: Node, b: Node): string;
        CmpExp_gt(a: Node, _op: Node, b: Node): string;
        CmpExp_le(a: Node, _op: Node, b: Node): string;
        CmpExp_lt(a: Node, _op: Node, b: Node): string;
        CmpExp_ne(a: Node, _op: Node, b: Node): string;
        DivExp_div(a: Node, _op: Node, b: Node): string;
        ExpExp_power(a: Node, _: Node, b: Node): string;
        ModExp_mod(a: Node, _op: Node, b: Node): string;
        MulExp_divide(a: Node, _op: Node, b: Node): string;
        MulExp_times(a: Node, _op: Node, b: Node): string;
        PriExp_neg(_op: Node, e: Node): string;
        PriExp_paren(_open: Node, e: Node, _close: Node): string;
        PriExp_pos(_op: Node, e: Node): string;
        StrAddExp_plus(a: Node, _op: Node, b: Node): string;
        StrCmpExp_eq(a: Node, _op: Node, b: Node): string;
        StrCmpExp_ge(a: Node, _op: Node, b: Node): string;
        StrCmpExp_gt(a: Node, _op: Node, b: Node): string;
        StrCmpExp_le(a: Node, _op: Node, b: Node): string;
        StrCmpExp_lt(a: Node, _op: Node, b: Node): string;
        StrCmpExp_ne(a: Node, _op: Node, b: Node): string;
        StrPriExp_paren(_open: Node, e: Node, _close: Node): string;
        ArrayArgs(args: Node): string;
        ArrayIdent(ident: Node, _open: Node, e: Node, _close: Node): string;
        DimArrayArgs(args: Node): string;
        DimArrayIdent(ident: Node, _open: Node, indices: Node, _close: Node): string;
        StrArrayIdent(ident: Node, _open: Node, e: Node, _close: Node): string;
        decimalValue(value: Node): string;
        hexValue(_prefix: Node, value: Node): string;
        binaryValue(_prefix: Node, value: Node): string;
        signedDecimal(sign: Node, value: Node): string;
        string(_quote1: Node, e: Node, _quote2: Node): string;
        ident(ident: Node): string;
        fnIdent(fn: Node, ident: Node): string;
        strIdent(ident: Node, typeSuffix: Node): string;
        strFnIdent(fn: Node, ident: Node, typeSuffix: Node): string;
    };
    getSemanticsActionDict(): ActionDict<string>;
    getHelper(): SemanticsHelper;
    getCodeSnippets4Test(data: Partial<typeof codeSnippetsData>): {
        resetText: () => void;
        after: (timeout: number, timer: number, fn: () => void) => void;
        bin$: (num: number, pad?: number) => string;
        cls: () => void;
        dec$: (num: number, format: string) => string;
        dim: (dims: number[], value?: string | number) => RecursiveArray<string | number>;
        dim1: (dim: number, value?: string | number) => any[];
        draw: (x: number, y: number) => void;
        drawr: (x: number, y: number) => void;
        end: () => string;
        every: (timeout: number, timer: number, fn: () => void) => void;
        frame: () => Promise<void>;
        graphicsPen: (num: number) => void;
        hex$: (num: number, pad?: number) => string;
        ink: (num: number, col: number) => void;
        inkey$: () => Promise<string>;
        input: (msg: string, isNum: boolean) => Promise<string | number>;
        mid$Assign: (s: string, start: number, newString: string, len?: number) => string;
        mode: (num: number) => void;
        move: (x: number, y: number) => void;
        mover: (x: number, y: number) => void;
        origin: (x: number, y: number) => void;
        paper: (n: number) => void;
        pen: (n: number) => void;
        plot: (x: number, y: number) => void;
        plotr: (x: number, y: number) => void;
        pos: () => number;
        printText: (text: string) => void;
        print: (...args: (string | number)[]) => void;
        read: () => string | number;
        remain: (timer: number) => number | NodeJS.Timeout | undefined;
        restore: (label: string) => void;
        round: (num: number, dec: number) => number;
        rsxCall: (cmd: string, ...args: (string | number)[]) => Promise<(string | number)[]>;
        stop: () => string;
        str$: (num: number) => string;
        tag: (active: boolean) => void;
        time: () => number;
        val: (str: string) => number;
        vpos: () => number;
        write: (...args: (string | number)[]) => void;
        xpos: () => number;
        ypos: () => number;
        zone: (num: number) => void;
    };
}
export {};
//# sourceMappingURL=Semantics.d.ts.map