import type { ActionDict, Node } from "ohm-js";
import type { ISemantics, UsedLabelEntryType } from "./Interfaces";
import { SemanticsHelper } from "./SemanticsHelper";
export declare class Semantics implements ISemantics {
    private readonly helper;
    constructor();
    resetParser(): void;
    getUsedLabels(): Record<string, Record<string, UsedLabelEntryType>>;
    getSemanticsActions(): {
        Program(lines: Node): string;
        LabelRange(start: Node, minus: Node, end: Node): string;
        LetterRange(start: Node, minus: Node, end: Node): string;
        Line(label: Node, stmts: Node, colons2: Node, comment: Node, _eol: Node): string;
        Statements(colons1: Node, stmt: Node, colons2: Node, stmts: Node): any;
        ArrayAssign(ident: Node, _op: Node, e: Node): string;
        Assign(ident: Node, _op: Node, e: Node): string;
        LoopBlockContent(separator: Node, stmts: Node): string;
        LoopBlockSeparator_colon(colons: Node): string;
        LoopBlockSeparator_newline(comment: Node, eol: Node, _label: Node): string;
        Abs(_absLit: Node, _open: Node, e: Node, _close: Node): string;
        AddressOf(op: Node, ident: Node): string;
        After(_afterLit: Node, e1: Node, _comma1: Node, e2: Node, _gosubLit: Node, label: Node): string;
        Asc(_ascLit: Node, _open: Node, str: Node, _close: Node): string;
        Atn(_atnLit: Node, _open: Node, num: Node, _close: Node): string;
        Auto(lit: Node, label: Node, comma: Node, step: Node): string;
        BinS(_binLit: Node, _open: Node, num: Node, _comma: Node, pad: Node, _close: Node): string;
        Border(lit: Node, num: Node, comma: Node, num2: Node): string;
        Call(lit: Node, args: Node): string;
        Cat: (str: Node, ...args: Node[]) => string;
        Chain(lit: Node, merge: Node, file: Node, comma: Node, num: Node, comma2: Node, del: Node): string;
        ChrS(_chrLit: Node, _open: Node, e: Node, _close: Node): string;
        Cint(_cintLit: Node, _open: Node, e: Node, _close: Node): string;
        Clear_clear: (str: Node, ...args: Node[]) => string;
        Clear_input(_lit: Node, _inputLit: Node): string;
        Clg(lit: Node, num: Node): string;
        Closein: (str: Node, ...args: Node[]) => string;
        Closeout: (str: Node, ...args: Node[]) => string;
        Cls(_clsLit: Node, stream: Node): string;
        Comment(_commentLit: Node, remain: Node): string;
        Cont: (str: Node, ...args: Node[]) => string;
        CopychrS(lit: Node, open: Node, stream: Node, close: Node): string;
        Cos: (lit: Node, _open: Node, num: Node, _close: Node) => string;
        Creal(_lit: Node, _open: Node, num: Node, _close: Node): string;
        Cursor(lit: Node, num: Node, comma: Node, num2: Node): string;
        Data(_datalit: Node, args: Node): string;
        DecS(_decLit: Node, _open: Node, num: Node, _comma: Node, format: Node, _close: Node): string;
        Def(_defLit: Node, _fnLit: Node, assign: Node): string;
        DefArgs(_open: Node, arrayIdents: Node, _close: Node): string;
        DefAssign(ident: Node, args: Node, _equal: Node, e: Node): string;
        Defint(_lit: Node, letterRange: Node): string;
        Defreal(lit: Node, letterRange: Node): string;
        Defstr(lit: Node, letterRange: Node): string;
        Deg(_degLit: Node): string;
        Delete(lit: Node, labelRange: Node): string;
        Derr(lit: Node): string;
        Di: (str: Node, ...args: Node[]) => string;
        Dim(_dimLit: Node, dimArgs: Node): string;
        Draw: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, pen: Node, _comma3: Node, mode: Node) => string;
        Drawr: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, pen: Node, _comma3: Node, mode: Node) => string;
        Edit(lit: Node, label: Node): string;
        Ei: (str: Node, ...args: Node[]) => string;
        End(_endLit: Node): string;
        Ent(lit: Node, nums: Node): string;
        Env(lit: Node, nums: Node): string;
        Eof(lit: Node): string;
        Erase(_eraseLit: Node, arrayIdents: Node): string;
        Erl(lit: Node): string;
        Err(lit: Node): string;
        Error(_errorLit: Node, e: Node): string;
        Every(_everyLit: Node, e1: Node, _comma1: Node, e2: Node, _gosubLit: Node, label: Node): string;
        Exp(_expLit: Node, _open: Node, num: Node, _close: Node): string;
        Fill(lit: Node, num: Node): string;
        Fix(_fixLit: Node, _open: Node, num: Node, _close: Node): string;
        Fre(lit: Node, open: Node, e: Node, close: Node): string;
        AnyFnArgs(_open: Node, args: Node, _close: Node): string;
        FnIdent(fnIdent: Node, args: Node): string;
        StrFnIdent(fnIdent: Node, args: Node): string;
        For(_forLit: Node, variable: Node, _eqSign: Node, start: Node, _dirLit: Node, end: Node, _stepLit: Node, step: Node): string;
        ForNextBlock: (startNode: Node, content: Node, separator: Node, endNode: Node) => string;
        Frame(_frameLit: Node): string;
        Gosub(_gosubLit: Node, e: Node): string;
        Goto(lit: Node, label: Node): string;
        GraphicsPaper(lit: Node, paperLit: Node, num: Node): string;
        GraphicsPen(_graphicsLit: Node, _penLit: Node, num: Node, _comma: Node, mode: Node): string;
        HexS(_hexLit: Node, _open: Node, num: Node, _comma: Node, pad: Node, _close: Node): string;
        Himem(lit: Node): string;
        IfExp_label(label: Node): string;
        IfThen_then(_thenLit: Node, thenStat: Node): any;
        If(_iflit: Node, condExp: Node, thenStat: Node, colons: Node, elseLit: Node, elseStat: Node): string;
        Ink(_inkLit: Node, num: Node, _comma: Node, col: Node, _comma2: Node, col2: Node): string;
        Inkey(lit: Node, open: Node, num: Node, close: Node): string;
        InkeyS(_inkeySLit: Node): string;
        Inp(lit: Node, open: Node, num: Node, close: Node): string;
        Input(_inputLit: Node, stream: Node, _comma: Node, _semi: Node, message: Node, _commaSemi: Node, ids: Node): string;
        Instr_noLen(_instrLit: Node, _open: Node, e1: Node, _comma: Node, e2: Node, _close: Node): string;
        Instr_len(_instrLit: Node, _open: Node, len: Node, _comma1: Node, e1: Node, _comma2: Node, e2: Node, _close: Node): string;
        Int(_intLit: Node, _open: Node, num: Node, _close: Node): string;
        Joy(lit: Node, open: Node, num: Node, close: Node): string;
        Key_key(lit: Node, num: Node, comma: Node, str: Node): string;
        Key_def(lit: Node, defLit: Node, num: Node, comma: Node, repeat: Node, comma2: Node, codes: Node): string;
        LeftS(_leftLit: Node, _open: Node, pos: Node, _comma: Node, len: Node, _close: Node): string;
        Len(_lenLit: Node, _open: Node, str: Node, _close: Node): string;
        Let(_letLit: Node, assign: Node): string;
        LineInput(_lit: Node, _inputLit: Node, stream: Node, _comma: Node, message: Node, _semi: Node, id: Node): string;
        List(lit: Node, labelRange: Node, comma: Node, stream: Node): string;
        Load(lit: Node, file: Node, comma: Node, address: Node): string;
        Locate(lit: Node, stream: Node, comma: Node, x: Node, comma2: Node, y: Node): string;
        Log(_logLit: Node, _open: Node, num: Node, _close: Node): string;
        Log10(_log10Lit: Node, _open: Node, num: Node, _close: Node): string;
        LowerS(_lowerLit: Node, _open: Node, str: Node, _close: Node): string;
        Mask(lit: Node, num: Node, comma: Node, num2: Node, comma2: Node, num3: Node): string;
        Max(_maxLit: Node, _open: Node, args: Node, _close: Node): string;
        Memory(lit: Node, num: Node): string;
        Merge(lit: Node, file: Node): string;
        MidS(_midLit: Node, _open: Node, str: Node, _comma1: Node, start: Node, _comma2: Node, len: Node, _close: Node): string;
        MidSAssign(_midLit: Node, _open: Node, ident: Node, _comma1: Node, start: Node, _comma2: Node, len: Node, _close: Node, _op: Node, newStr: Node): string;
        Min(_minLit: Node, _open: Node, args: Node, _close: Node): string;
        Mode(_modeLit: Node, num: Node): string;
        Move: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, pen: Node, _comma3: Node, mode: Node) => string;
        Mover: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, pen: Node, _comma3: Node, mode: Node) => string;
        New: (str: Node, ...args: Node[]) => string;
        Next(_nextLit: Node, _variable: Node): string;
        On_numGosub(_onLit: Node, e1: Node, _gosubLit: Node, args: Node): string;
        On_numGoto(_lit: Node, _num: Node, gotoLit: Node, labels: Node): string;
        On_breakCont(lit: Node, breakLit: Node, contLit: Node): string;
        On_breakGosub(lit: Node, breakLit: Node, gosubLit: Node, label: Node): string;
        On_breakStop(lit: Node, breakLit: Node, stopLit: Node): string;
        On_errorGoto(lit: Node, errorLit: Node, gotoLit: Node, label: Node): string;
        Openin(lit: Node, file: Node): string;
        Openout(lit: Node, file: Node): string;
        Origin(_originLit: Node, x: Node, _comma: Node, y: Node, _comma2: Node, win: Node): string;
        Out(lit: Node, num: Node, comma: Node, num2: Node): string;
        Paper(_paperLit: Node, stream: Node, _comma: Node, e: Node): string;
        Peek(lit: Node, open: Node, num: Node, close: Node): string;
        Pen(_penLit: Node, stream: Node, _comma: Node, e: Node, _comma2: Node, e2: Node): string;
        Pi(_piLit: Node): string;
        Plot: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, pen: Node, _comma3: Node, mode: Node) => string;
        Plotr: (lit: Node, x: Node, _comma1: Node, y: Node, _comma2: Node, pen: Node, _comma3: Node, mode: Node) => string;
        Poke(lit: Node, num: Node, comma: Node, num2: Node): string;
        Pos(lit: Node, open: Node, streamLit: Node, num: Node, close: Node): string;
        PrintArg_strCmp(_cmp: Node, args: Node): any;
        PrintArg_usingNum(_printLit: Node, format: Node, _semi: Node, numArgs: Node): string;
        PrintArg_commaOp(_comma: Node): string;
        StreamArg(streamLit: Node, stream: Node): string;
        Print(_printLit: Node, stream: Node, _comma: Node, args: Node, semi: Node): string;
        Rad(_radLit: Node): string;
        Randomize(lit: Node, num: Node): string;
        Read(_readlit: Node, args: Node): string;
        Release(lit: Node, num: Node): string;
        Rem(_remLit: Node, remain: Node): string;
        Remain(_remainLit: Node, _open: Node, e: Node, _close: Node): string;
        Renum(lit: Node, num: Node, comma: Node, num2: Node, comma2: Node, num3: Node): string;
        Restore(_restoreLit: Node, e: Node): string;
        Resume(lit: Node, labelOrNext: Node): string;
        Return(_returnLit: Node): string;
        RightS(_rightLit: Node, _open: Node, str: Node, _comma: Node, len: Node, _close: Node): string;
        Rnd(_rndLit: Node, _open: Node, e: Node, _close: Node): string;
        Round(_roundLit: Node, _open: Node, num: Node, _comma: Node, decimals: Node, _close: Node): string;
        Rsx(_rsxLit: Node, cmd: Node, e: Node): string;
        RsxAddressOf(_adressOfLit: Node, ident: Node): string;
        RsxArgs(_comma: Node, args: Node): string;
        Run(lit: Node, labelOrFileOrNoting: Node): string;
        Save(lit: Node, file: Node, comma: Node, type: Node, comma2: Node, num: Node, comma3: Node, num2: Node, comma4: Node, num3: Node): string;
        Sgn(_sgnLit: Node, _open: Node, num: Node, _close: Node): string;
        Sin: (lit: Node, _open: Node, num: Node, _close: Node) => string;
        Sound(lit: Node, state: Node, comma: Node, period: Node, comma2: Node, args: Node): string;
        SpaceS(_stringLit: Node, _open: Node, num: Node, _close: Node): string;
        Spc(_lit: Node, _open: Node, num: Node, _close: Node): string;
        Speed_ink(lit: Node, inkLit: Node, num: Node, comma: Node, num2: Node): string;
        Speed_key(lit: Node, keyLit: Node, num: Node, comma: Node, num2: Node): string;
        Speed_write(lit: Node, writeLit: Node, num: Node): string;
        Sq(lit: Node, open: Node, num: Node, close: Node): string;
        Sqr(_sqrLit: Node, _open: Node, num: Node, _close: Node): string;
        Stop(_stopLit: Node): string;
        StrS(_strLit: Node, _open: Node, num: Node, _close: Node): string;
        StringS_str(_stringLit: Node, _open: Node, len: Node, _commaLit: Node, chr: Node, _close: Node): string;
        StringS_num(_stringLit: Node, _open: Node, len: Node, _commaLit: Node, num: Node, _close: Node): string;
        Symbol_def(lit: Node, args: Node): string;
        Symbol_after(lit: Node, afterLit: Node, num: Node): string;
        Tab(_lit: Node, _open: Node, num: Node, _close: Node): string;
        Tag(lit: Node, stream: Node): string;
        Tagoff(lit: Node, stream: Node): string;
        Tan: (lit: Node, _open: Node, num: Node, _close: Node) => string;
        Test(lit: Node, open: Node, num: Node, comma: Node, num2: Node, close: Node): string;
        Testr(lit: Node, open: Node, num: Node, comma: Node, num2: Node, close: Node): string;
        Time(_timeLit: Node): string;
        Troff: (str: Node, ...args: Node[]) => string;
        Tron: (str: Node, ...args: Node[]) => string;
        Unt(_lit: Node, _open: Node, num: Node, _close: Node): string;
        UpperS(_upperLit: Node, _open: Node, str: Node, _close: Node): string;
        Val(_upperLit: Node, _open: Node, e: Node, _close: Node): string;
        Vpos(lit: Node, open: Node, streamLit: Node, num: Node, close: Node): string;
        Wait(lit: Node, num: Node, comma: Node, num2: Node, comma2: Node, num3: Node): string;
        Wend(_wendLit: Node): string;
        While(_whileLit: Node, e: Node): string;
        WhileWendBlock: (startNode: Node, content: Node, separator: Node, endNode: Node) => string;
        Width(lit: Node, num: Node): string;
        Window_def(lit: Node, stream: Node, comma0: Node, num: Node, comma: Node, num2: Node, comma2: Node, num3: Node, comma3: Node, num4: Node): string;
        Window_swap(lit: Node, swapLit: Node, num: Node, comma: Node, num2: Node): string;
        Write(_printLit: Node, stream: Node, _comma: Node, args: Node): string;
        Xpos(_xposLit: Node): string;
        Ypos(_xposLit: Node): string;
        Zone(_lit: Node, num: Node): string;
        AndExp_and(a: Node, _op: Node, b: Node): string;
        NotExp_not(_op: Node, e: Node): string;
        OrExp_or(a: Node, _op: Node, b: Node): string;
        XorExp_xor(a: Node, _op: Node, b: Node): string;
        AddExp_minus(a: Node, _op: Node, b: Node): string;
        AddExp_plus(a: Node, _op: Node, b: Node): string;
        CmpExp_eq(a: Node, _op: Node, b: Node): string;
        CmpExp_ge(a: Node, _op: Node, b: Node): string;
        CmpExp_gt(a: Node, _op: Node, b: Node): string;
        CmpExp_le(a: Node, _op: Node, b: Node): string;
        CmpExp_lt(a: Node, _op: Node, b: Node): string;
        CmpExp_ne(a: Node, _op: Node, b: Node): string;
        DivExp_div(a: Node, _op: Node, b: Node): string;
        ExpExp_power(a: Node, _: Node, b: Node): string;
        ModExp_mod(a: Node, _op: Node, b: Node): string;
        MulExp_divide(a: Node, _op: Node, b: Node): string;
        MulExp_times(a: Node, _op: Node, b: Node): string;
        PriExp_neg(_op: Node, e: Node): string;
        PriExp_paren(_open: Node, e: Node, _close: Node): string;
        PriExp_pos(_op: Node, e: Node): string;
        StrAddExp_plus(a: Node, _op: Node, b: Node): string;
        StrCmpExp_eq(a: Node, _op: Node, b: Node): string;
        StrCmpExp_ge(a: Node, _op: Node, b: Node): string;
        StrCmpExp_gt(a: Node, _op: Node, b: Node): string;
        StrCmpExp_le(a: Node, _op: Node, b: Node): string;
        StrCmpExp_lt(a: Node, _op: Node, b: Node): string;
        StrCmpExp_ne(a: Node, _op: Node, b: Node): string;
        StrPriExp_paren(_open: Node, e: Node, _close: Node): string;
        ArrayArgs(args: Node): string;
        ArrayIdent(ident: Node, _open: Node, e: Node, _close: Node): string;
        DimArrayArgs(args: Node): string;
        DimArrayIdent(ident: Node, _open: Node, indices: Node, _close: Node): string;
        StrArrayIdent(ident: Node, _open: Node, e: Node, _close: Node): string;
        CondExp(e: Node): any;
        dataUnquoted(data: Node): string;
        decimalValue(value: Node): string;
        hexValue(_prefix: Node, value: Node): string;
        binaryValue(_prefix: Node, value: Node): string;
        string(_quote1: Node, e: Node, quote2: Node): string;
        ident(ident: Node, suffix: Node): string;
        fnIdent(fn: Node, _space: Node, ident: Node, suffix: Node): string;
        strIdent(ident: Node, typeSuffix: Node): string;
        strFnIdent(fn: Node, _space: Node, ident: Node, typeSuffix: Node): string;
    };
    getSemanticsActionDict(): ActionDict<string>;
    getHelper(): SemanticsHelper;
}
//# sourceMappingURL=Semantics.d.ts.map