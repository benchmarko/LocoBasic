import type { BrowserWorkerThreadsType, MessageFromWorker, MessageToWorker, NodeWorkerThreadsType } from "../Interfaces";
type RecursiveArray<T> = T | RecursiveArray<T>[];
type RestoreMapType = Record<string, number>;
export declare const workerFn: (parentPort: NodeWorkerThreadsType["parentPort"] | BrowserWorkerThreadsType["parentPort"]) => {
    _commaOpChar: string;
    _tabOpChar: string;
    _ansiColorCodes: number[];
    _cpcColors: string[];
    _cpcDefaultColorsForPens: number[];
    _cpcStrokeWidthForMode: number[];
    _isTerminal: boolean;
    _data: (string | number)[];
    _dataPtr: number;
    _graBackgroundColor: string;
    _graColorsForPens: number[];
    _graCurrGraphicsPen: number;
    _graCurrMode: number;
    _graOriginX: number;
    _graOriginY: number;
    _graGraphicsBuffer: string[];
    _graGraphicsPathBuffer: string[];
    _graGraphicsX: number;
    _graGraphicsY: number;
    _graOutputGraphicsIndex: number;
    _keyCharBufferString: string;
    _needCls: boolean;
    _output: string;
    _paperSpanPos: number;
    _paperValue: number;
    _penSpanPos: number;
    _penValue: number;
    _pos: number;
    _restoreMap: RestoreMapType;
    _rsxPitch: number;
    _startTime: number;
    _stopRequested: boolean;
    _tag: boolean;
    _timerMap: Record<number, (number | NodeJS.Timeout)>;
    _vpos: number;
    _zone: number;
    _inputResolvedFn: ((value: string | null) => void) | null;
    _waitResolvedFn: ((value: string) => void) | null;
    deleteAllItems: (items: Record<string, unknown>) => void;
    formatCommaOrTab: (str: string) => string;
    formatNumber: (arg: number) => string;
    onMessageHandler: (data: MessageToWorker) => void;
    postMessage: (message: MessageFromWorker) => void;
    resetAll: () => void;
    resetColorsForPens: () => void;
    resetGra: () => void;
    resolveInput: (input: string | null) => void;
    resolveWait: (result: string) => void;
    abs: (num: number) => number;
    after: (timeout: number, timer: number, fn: () => void) => void;
    asc: (str: string) => number;
    atn: (num: number) => number;
    bin$: (num: number, pad?: number) => string;
    chr$: (num: number) => string;
    cint: (num: number) => number;
    clearInput: () => void;
    cls: () => void;
    cos: (num: number) => number;
    creal: (num: number) => number;
    dec$: (num: number, format: string) => string;
    dim: (dims: number[], value?: string | number) => RecursiveArray<string | number>;
    dim1: (dim: number, value?: number) => number[];
    draw: (x: number, y: number, pen?: number) => void;
    drawr: (x: number, y: number, pen?: number) => void;
    end: () => string;
    escapeText: (str: string) => string;
    every: (timeout: number, timer: number, fn: () => void) => void;
    exp: (num: number) => number;
    fix: (num: number) => number;
    flush: () => string;
    frame: () => Promise<void>;
    getAnsiColorCodeForPen: (pen: number) => number;
    getFlushedText: () => string;
    graAddGraphicsElement: (element: string) => void;
    graCls: () => void;
    graDrawMovePlot: (type: string, x: number, y: number, pen?: number) => void;
    graFlushGraphicsPath: () => void;
    graGetFlushedGraphics: () => string;
    graGetStrokeAndFillStr: (fill: number) => string;
    graGetTagInSvg: (content: string) => string;
    graGetRgbColorStringForPen: (pen: number) => string;
    graPrintGraphicsText: (text: string) => void;
    graSetOutputGraphicsIndex: () => void;
    handleTrailingNewline: (str: string) => string;
    getFlushedTextandGraphics: () => string;
    graphicsPen: (num: number) => void;
    hex$: (num: number, pad?: number) => string;
    ink: (num: number, col: number) => void;
    inkey$: () => Promise<string>;
    input: (prompt: string, types: string) => Promise<(string | number)[]>;
    instr: (str: string, find: string, len: number) => number;
    int: (num: number) => number;
    keyDef: (num: number, repeat: number, ...codes: number[]) => void;
    left$: (str: string, num: number) => string;
    len: (str: string) => number;
    lineInput: (prompt: string) => Promise<string>;
    log: (num: number) => number;
    log10: (num: number) => number;
    lower$: (str: string) => string;
    max: (...nums: number[]) => number;
    mid$: (str: string, pos: number, len?: number) => string;
    mid$Assign: (s: string, start: number, newString: string, len?: number) => string;
    min: (...nums: number[]) => number;
    mode: (num: number) => void;
    move: (x: number, y: number, pen?: number) => void;
    mover: (x: number, y: number, pen?: number) => void;
    origin: (x: number, y: number) => void;
    paper: (n: number) => void;
    pen: (n: number) => void;
    pi: number;
    plot: (x: number, y: number, pen?: number) => void;
    plotr: (x: number, y: number, pen?: number) => void;
    pos: () => number;
    print: (...args: (string | number)[]) => void;
    printTab: (...args: (string | number)[]) => void;
    printText: (text: string) => void;
    read: () => string | number;
    remain: (timer: number) => number | NodeJS.Timeout;
    remainAll: () => void;
    restore: (label: string) => void;
    right$: (str: string, num: number) => string;
    rnd: () => number;
    round1: (num: number) => number;
    round: (num: number, dec: number) => number;
    rsxArc: (...args: number[]) => void;
    rsxCircle: (...args: number[]) => void;
    rsxDate: (...args: string[]) => string[];
    rsxEllipse: (...args: number[]) => void;
    rsxGeolocation: (...args: string[]) => Promise<string[]>;
    rsxPitch: (args: number[]) => void;
    rsxRect: (...args: number[]) => void;
    rsxSay: (...args: string[]) => Promise<string>;
    rsxTime: (...args: string[]) => string[];
    sgn: (num: number) => number;
    sin: (num: number) => number;
    space$: (num: number) => string;
    spc: (num: number) => string;
    sqr: (num: number) => number;
    stop: () => string;
    str$: (num: number) => string;
    string$Num: (len: number, num: number) => string;
    string$Str: (len: number, str: string) => string;
    tag: () => void;
    tagoff: () => void;
    tan: (num: number) => number;
    time: () => number;
    toDeg: (num: number) => number;
    toRad: (num: number) => number;
    using: (format: string, ...args: number[]) => string;
    unt: (num: number) => number;
    upper$: (str: string) => string;
    val1: (str: string) => number;
    val: (str: string) => number;
    vpos: () => number;
    write: (...args: (string | number)[]) => void;
    xpos: () => number;
    ypos: () => number;
    zone: (num: number) => void;
};
export {};
//# sourceMappingURL=VmWorker.d.ts.map