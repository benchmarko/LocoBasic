import type { MessageFromWorker, MessageToWorker } from "../Interfaces";
interface NodeWorkerThreads {
    parentPort: {
        postMessage: (message: MessageFromWorker) => void;
        on: (event: string, listener: (data: MessageToWorker) => void) => void;
    };
}
export declare const workerFn: (parentPort?: NodeWorkerThreads["parentPort"]) => {
    _gra: {
        _backgroundColor: string;
        _colorsForPens: number[];
        _currGraphicsPen: number;
        _currMode: number;
        _originX: number;
        _originY: number;
        _graphicsBuffer: string[];
        _graphicsPathBuffer: string[];
        _graphicsX: number;
        _graphicsY: number;
        _outputGraphicsIndex: number;
        resetGra: () => void;
        addGraphicsElement(element: string): void;
        cls: () => void;
        drawMovePlot: (type: string, x: number, y: number, pen?: number) => void;
        flushGraphicsPath(): void;
        getFlushedGraphics(): string;
        getRgbColorStringForPen: (pen: number) => string;
        graphicsPen: (num: number) => void;
        ink: (num: number, col: number) => void;
        mode: (num: number) => void;
        origin: (x: number, y: number) => void;
        printGraphicsText: (text: string) => void;
        getStrokeAndFillStr(fill: number): string;
        rsxArc: (args: (number | string)[]) => void;
        rsxCircle: (args: (number | string)[]) => void;
        rsxEllipse: (args: (number | string)[]) => void;
        rsxRect: (args: (number | string)[]) => void;
        setOutputGraphicsIndex: () => void;
        xpos: () => number;
        ypos: () => number;
    };
    _rsx: {
        _pitch: number;
        resetRsx: () => void;
        rsxDate: (args: (number | string)[]) => Promise<(string | number)[]>;
        rsxPitch: (args: (number | string)[]) => void;
        rsxSay: (args: (number | string)[]) => void;
        rsxTime: (args: (number | string)[]) => Promise<(string | number)[]>;
    };
    _inputResolvedFn: ((value: string) => void) | null;
    _waitResolvedFn: (() => void) | null;
    _isTerminal: boolean;
    _data: (string | number)[];
    _dataPtr: number;
    _keyCharBufferString: string;
    _needCls: boolean;
    _output: string;
    _paperSpanPos: number;
    _paperValue: number;
    _penSpanPos: number;
    _penValue: number;
    _pos: number;
    _restoreMap: Record<string, number>;
    _startTime: number;
    _stopRequested: boolean;
    _tag: boolean;
    _timerMap: Record<number, (number | NodeJS.Timeout)>;
    _vpos: number;
    _zone: number;
    resetAll: () => void;
    abs: (num: number) => number;
    after: (timeout: number, timer: number, fn: () => void) => void;
    asc: (str: string) => number;
    atn: (x: number) => number;
    bin$: (num: number, pad?: number) => string;
    chr$: (num: number) => string;
    cint: (num: number) => number;
    cls: () => void;
    cos: (x: number) => number;
    creal: (num: number) => number;
    dec$: (num: number, format: string) => string;
    dim: (dims: number[], value?: string | number) => string | number | (string | number | (string | number | (string | number | (string | number | (string | number | (string | number | (string | number | (string | number | (string | number | (string | number | (string | number | /*elided*/ any)[])[])[])[])[])[])[])[])[])[])[];
    dim1: (dim: number, value?: string | number) => any[];
    draw: (x: number, y: number, pen?: number) => void;
    drawr: (x: number, y: number, pen?: number) => void;
    end: () => string;
    escapeText(str: string, isGraphics?: boolean): string;
    every: (timeout: number, timer: number, fn: () => void) => void;
    exp: (num: number) => number;
    fix: (num: number) => number;
    frame: () => Promise<void>;
    getFlushedText: () => string;
    handleTrailingNewline(str: string): string;
    getFlushedTextandGraphics: () => string;
    graphicsPen: () => (num: number) => void;
    hex$: (num: number, pad?: number) => string;
    ink: (num: number, col: number) => void;
    inkey$: () => Promise<string>;
    input: (prompt: string, isNum: boolean) => Promise<string | number>;
    instr: (str: string, find: string, len: number) => number;
    int: (num: number) => number;
    keyDef(num: number, repeat: number, ...codes: number[]): void;
    left$: (str: string, num: number) => string;
    len: (str: string) => number;
    log: (num: number) => number;
    log10: (num: number) => number;
    lower$: (str: string) => string;
    max: (...values: number[]) => number;
    mid$: (str: string, pos: number, len?: number) => string;
    mid$Assign: (s: string, start: number, newString: string, len?: number) => string;
    min: (...values: number[]) => number;
    mode: (num: number) => void;
    move: (x: number, y: number, pen?: number) => void;
    mover: (x: number, y: number, pen?: number) => void;
    origin: (x: number, y: number) => void;
    paper: (n: number) => void;
    pen(n: number): void;
    pi: number;
    plot: (x: number, y: number, pen?: number) => void;
    plotr: (x: number, y: number, pen?: number) => void;
    pos: () => number;
    print: (...args: (string | number)[]) => void;
    printTab: (...args: (string | number)[]) => void;
    printText: (text: string) => void;
    read: () => string | number;
    remain: (timer: number) => number | NodeJS.Timeout;
    remainAll: () => void;
    restore: (label: string) => void;
    right$: (str: string, num: number) => string;
    rnd: () => number;
    round1: (x: number) => number;
    round: (num: number, dec: number) => number;
    rsxCall: (cmd: string, ...args: (string | number)[]) => Promise<void | (string | number)[]>;
    sgn: (x: number) => number;
    sin: (x: number) => number;
    space$: (num: number) => string;
    spc: (num: number) => string;
    sqr: (x: number) => number;
    stop: () => string;
    str$: (num: number) => string;
    string$Num: (len: number, num: number) => string;
    string$Str: (len: number, str: string) => string;
    tag: () => boolean;
    tagoff: () => boolean;
    tan: (x: number) => number;
    time: () => number;
    toDeg: (num: number) => number;
    toRad: (num: number) => number;
    using: (format: string, ...args: number[]) => string;
    unt: (num: number) => number;
    upper$: (str: string) => string;
    val1: (str: string) => number;
    val: (str: string) => number;
    vpos: () => number;
    write: (...args: (string | number)[]) => void;
    xpos: () => () => number;
    ypos: () => () => number;
    zone: (num: number) => void;
};
export {};
//# sourceMappingURL=VmWorker.d.ts.map